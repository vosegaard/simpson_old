/* Automatically generated. Do not edit ! */
#include "tclutil.h"

char csafit_tcl[] = 
    "\n"
    "proc showiso {} {\n"
    "  global g f\n"
    "\n"
    "  set lst {}\n"
    "  lappend lst \"srate: $g(srate)\"\n"
    "  for {set n 1} {$n <= $f(npeaks)} {incr n} {  \n"
    "    set iso [expr $g(iso$n)]\n"
    "    set isoppm [expr $iso / $f(spec-freq)]\n"
    "    set anisoppm [expr $g(aniso$n) / $f(spec-freq)]\n"
    "    set lb [expr double(abs($g(gauss$n))) + double(abs($g(lorentz$n)))]\n"
    "    set frac [expr abs(double($g(gauss$n)) / double($lb))]\n"
    "    lappend lst [format \"   %d) %5.2f ppm    %6.2f ppm    %.3f    %5.1f Hz/%4.2f    %4.1f%%\" \\\n"
    "          $n $isoppm $anisoppm $g(eta$n) $lb $frac [expr $g(area$n) / $g(sumarea) * 100.0]]\n"
    "  }\n"
    "  return $lst\n"
    "}\n"
    "\n"
    "\n"
    "proc evalfunc {val {skip 1}} {\n"
    "  global f g\n"
    "\n"
    "  foreach i $val {\n"
    "    set g([lindex $i 0]) [lindex $i 1]\n"
    "  }\n"
    "  csasetspinrate $g(srate)\n"
    "  set f1 [fcreate -np $f(zerofill) -type spe -sw $f(specwidth) -ref $f(ref-scale)]\n"
    "  set g(sumarea) 0.0\n"
    "  for {set n 1} {$n <= $f(npeaks)} {incr n} {\n"
    "    set intlb {}\n"
    "    csaspec $g(aniso$n) $g(eta$n)\n"
    "    set int [csareturnint $g(iso$n) [expr abs($g(scale$n))]]\n"
    "    set lb [expr double(abs($g(gauss$n))) + double(abs($g(lorentz$n)))]\n"
    "    set lg [expr abs(double($g(gauss$n)) / double($lb))]\n"
    "    foreach i $int {\n"
    "       set ssb [expr abs([lindex $i 0])]\n"
    "       lappend intlb [concat [lrange $i 1 2 ] $lb $lg]\n"
    "    }\n"
    "    set arealist [faddpeaks $f1 $f(truncate) $intlb]\n"
    "    set area 0.0\n"
    "    foreach a $arealist {\n"
    "       set area [expr $area + $a]\n"
    "    }\n"
    "    set g(area$n) $area\n"
    "    set g(sumarea) [expr $g(sumarea) + $g(area$n)]\n"
    "  }\n"
    "  if $f(save) {\n"
    "     puts \"Saving $f(savename) ...\"\n"
    "     fsave $f1 $f(savename)     \n"
    "     set f(save) 0\n"
    "  }\n"
    "  set rms [frms $f1 $f(expspe) $f(range) -re]  \n"
    "  funload $f1\n"
    "\n"
    "  if [expr ($f(iter) % 10) == 0] {\n"
    "     puts -nonewline \"\\nIter: $f(iter)  rms: [format %.7f $rms]  \"\n"
    "     set f(showiso) [showiso]\n"
    "     set f(rms) $rms\n"
    "     puts [join $f(showiso) \"\\n\"]\n"
    "     flush stdout\n"
    "  }\n"
    "  return  $rms\n"
    "}\n"
    "\n"
    "proc setbestvalues {} {\n"
    "  global f\n"
    "  array set ary [split $f(bestval)]\n"
    "  set lst {}\n"
    "  foreach i $f(values) {\n"
    "    set name [lindex $i 0]\n"
    "    lappend lst [concat $name $ary($name) [lrange $i 2 999]]\n"
    "  }\n"
    "  set f(values) $lst\n"
    "}\n"
    "\n"
    "proc loadpar {parfile} {\n"
    "  global f\n"
    "  puts -nonewline \"Loading $parfile\"\n"
    "  set fp [open $parfile.par]\n"
    "  set f(values) {}\n"
    "  while {[gets $fp s] != -1} {\n"
    "    if [llength $s] {\n"
    "      regsub -all {[ ]+} [string trim $s] { } s\n"
    "      lappend f(values) $s\n"
    "    }\n"
    "  }\n"
    "  close $fp\n"
    "  set n 0\n"
    "  foreach i $f(values) {\n"
    "    if [string match iso* [lindex $i 0]] {\n"
    "      incr n\n"
    "    }\n"
    "  }\n"
    "  set f(npeaks) $n\n"
    "  flush stdout\n"
    "}\n"
    "\n"
    "proc setdefpar {} {\n"
    "  global f par\n"
    "  if ![info exists f(save)] {set f(save) 0}\n"
    "  if ![info exists f(name)] {set f(name) fit}\n"
    "  if ![info exists f(savename)] {set f(savename) $par(name).spe }\n"
    "  if ![info exists f(skip)] {set f(skip) 1}\n"
    "  if ![info exists f(function)] {set f(function) fitfunc}\n"
    "  if ![info exists f(method)] {set f(method) simplex }\n"
    "  if ![info exists f(max-change)] {set f(max-change) 0.0}\n"
    "  if ![info exists f(max-change-iter)] {set f(max-change-iter) 30}\n"
    "  if ![info exists f(max-value)] {set f(max-value) 999999}\n"
    "  if ![info exists f(max-iter)] {set f(max-iter) 999999}\n"
    "  if ![info exists f(output-name)] {set f(output-name) peaks}\n"
    "  if ![info exists f(save-per-iter)] {set f(save-per-iter) 100 }\n"
    "  if ![info exists f(range)] {set f(range) {{-1e99 1e99}}}\n"
    "  if ![info exists f(text)] {set f(text) {\"Simulation\"}}\n"
    "  if ![info exists f(iter)] {set f(iter) 0}\n"
    "}\n"
    "\n"
    "proc savepar {} {\n"
    "  global f\n"
    "  \n"
    "  setdefpar\n"
    "  puts \"Saving $f(name).par and $f(name).spe\"\n"
    "  flush stdout\n"
    "  set fp [open $f(name).par w]\n"
    "  foreach i $f(values) {\n"
    "    foreach j $i {\n"
    "      puts -nonewline $fp [format \"%15s\" $j]\n"
    "    }\n"
    "    puts $fp \"\" \n"
    "  }\n"
    "  close $fp\n"
    "  set lst {}\n"
    "  foreach i $f(values) {\n"
    "    lappend lst [lrange $i 0 1]\n"
    "  }\n"
    "  set f(save) 1\n"
    "  set f(savename) $f(name).spe\n"
    "  evalfunc $lst $f(skip)\n"
    "} \n"
    "\n"
    "proc savepeaks {} {\n"
    "  global f\n"
    "\n"
    "  setdefpar\n"
    "  puts \"Saving $f(name).par\"\n"
    "  flush stdout\n"
    "  set fp [open $f(output-name).par w]\n"
    "  foreach i $f(values) {\n"
    "    foreach j $i {\n"
    "      puts -nonewline $fp [format \"%15s\" $j]\n"
    "    }\n"
    "    puts $fp \"\" \n"
    "  }\n"
    "  close $fp\n"
    "\n"
    "  puts \"Saving $f(name).spe\"\n"
    "  flush stdout\n"
    "  set lst {}\n"
    "  foreach i $f(values) {\n"
    "    lappend lst [lrange $i 0 1]\n"
    "  }\n"
    "  set f(save) 1\n"
    "  set f(savename) $f(name).spe\n"
    "  evalfunc $lst $f(skip)\n"
    "\n"
    "  puts \"Saving $f(name).txt\"\n"
    "  flush stdout\n"
    "  set fp [open $f(name).txt w]\n"
    "  puts $fp [join $f(text) \\n]\n"
    "  set form [format \"%6.4f\" $f(rms)]\n"
    "  set srate [lindex [lindex $f(showiso) 0] 1]\n"
    "  puts $fp \"Simulated spectrum (rms: $form, spinrate: $srate) with chemical shift, anisotropy\"\n"
    "  puts $fp \"(defined as dzz-diso), asymmetry, linebroadening/lorentz fraction and intensity: \"\n"
    "  puts $fp [join [lrange $f(showiso) 1 999] \\n]\n"
    "  close $fp\n"
    "\n"
    "  set npeaks $f(npeaks)\n"
    "\n"
    "  for {set site 1} {$site <= $npeaks} {incr site} {\n"
    "    set other {}\n"
    "    set lst {}\n"
    "\n"
    "    foreach i $f(values) {   \n"
    "      set nam [lindex $i 0]\n"
    "      if [regexp ^\\[a-zA-Z_\\]*$ $nam] {\n"
    "        lappend other [lrange $i 0 1]\n"
    "      } elseif [regexp ^\\[a-zA-Z_\\]*${site}$ $nam] {\n"
    "        regsub ^(\\[a-zA-Z_\\]*)(${site})$ $nam {\\1} base\n"
    "        set base \"${base}1\"\n"
    "        lappend lst \"$base [lindex $i 1]\"\n"
    "      }\n"
    "    }\n"
    "    if [llength $lst] {\n"
    "       set lst [concat $other $lst]\n"
    "       set f(npeaks) 1\n"
    "       puts \"Saving $f(name)-$site.spe\"\n"
    "       flush stdout\n"
    "       set f(save) 1\n"
    "       set f(savename) $f(name)-$site.spe\n"
    "       evalfunc $lst $f(skip)\n"
    "    } else {\n"
    "      break\n"
    "    }\n"
    "  }\n"
    "  set f(npeaks) $npeaks\n"
    "} \n"
    "\n"
    "proc fitfunc {val} {\n"
    "  global f stop\n"
    "\n"
    "  if {$f(iter) > $f(max-iter)} {\n"
    "    puts \"Maxiter reached\"\n"
    "    set stop 1\n"
    "  }\n"
    "  if $stop {\n"
    "     set stop 0\n"
    "     puts \"Printing and saving best fit.\"\n"
    "     set f(iter) 0\n"
    "     setbestvalues\n"
    "     savepar\n"
    "     puts \"\"\n"
    "     foreach i $f(values) {\n"
    "        foreach j $i {\n"
    "          puts -nonewline [format \"%15s\" $j]\n"
    "        }\n"
    "        puts \"\" \n"
    "     }\n"
    "     puts \"\"\n"
    "     puts stderr \"Program terminated.\"\n"
    "     exit\n"
    "  }\n"
    "  incr f(iter)\n"
    "  set rms [evalfunc $val $f(skip)]\n"
    "  if [expr $rms < $f(bestrms)] {\n"
    "    set f(bestrms) $rms\n"
    "    set f(bestval) $val\n"
    "  }\n"
    "  if [expr ($f(iter) % $f(save-per-iter)) == 0] {\n"
    "    setbestvalues\n"
    "    savepar\n"
    "  }\n"
    "  return $rms\n"
    "}\n"
    " \n"
    "\n"
    "proc fitpar {} {\n"
    "  global f\n"
    "\n"
    "  setdefpar\n"
    "\n"
    "  set f(bestrms) 1e99\n"
    "  set f(bestval) {}\n"
    "  set f(iter) 0\n"
    "  fit f\n"
    "  setbestvalues\n"
    "}\n"
    "\n"
    "proc tolist {lst} {\n"
    "  set l {}\n"
    "  foreach j [split $lst \"\\n\"] {\n"
    "    if [llength $j] {\n"
    "      lappend l $j\n"
    "    }\n"
    "  }\n"
    "  return $l\n"
    "}\n"
    "\n"
    "proc setfitvar {var val} {\n"
    "  global f\n"
    "  set lst {}\n"
    "  foreach i $f(values) {\n"
    "     set nam [lindex $i 0]\n"
    "     if [string match $var $nam] {\n"
    "       lappend lst [list $nam $val [lindex $i 2] 1]\n"
    "     } else {\n"
    "       lappend lst $i\n"
    "     }\n"
    "  }\n"
    "  set f(values) $lst\n"
    "}\n"
    "\n"
    "proc release args {\n"
    "  global f\n"
    "  foreach var $args {\n"
    "    set lst {}\n"
    "    foreach i $f(values) {\n"
    "       set nam [lindex $i 0]\n"
    "       if [string match $var $nam] {\n"
    "         lappend lst [list $nam [lindex $i 1] [lindex $i 2] 1]\n"
    "       } else {\n"
    "         lappend lst $i\n"
    "       }\n"
    "    }\n"
    "    set f(values) $lst\n"
    "  }\n"
    "}\n"
    "\n"
    "proc fix args {\n"
    "  global f\n"
    "  foreach var $args {\n"
    "    set lst {}\n"
    "    foreach i $f(values) {\n"
    "       set nam [lindex $i 0]\n"
    "       if [string match $var $nam] {\n"
    "         lappend lst [list $nam [lindex $i 1] [lindex $i 2] 0]\n"
    "       } else {\n"
    "         lappend lst $i\n"
    "       }\n"
    "    }\n"
    "    set f(values) $lst\n"
    "  }\n"
    "}\n"
    "\n"
    "proc setpar {lst} {\n"
    "  global f\n"
    "\n"
    "  set n 0\n"
    "  set f(values) {}\n"
    "  foreach i [split $lst \"\\n\"] {\n"
    "    if [llength $i] {\n"
    "      lappend f(values) $i\n"
    "      if [string match iso* [lindex $i 0]] {\n"
    "        incr n\n"
    "      }\n"
    "    }\n"
    "  }\n"
    "  set f(npeaks) $n\n"
    "}\n"
    ;
/* EOF */
/* This file has been generated from the following Tcl source file(s):
 *    ftools.tcl
 * on Mon Nov 23 15:44:59 CET 2009 by zdenek
 */

char ftools_tcl[] = 
    "\n"
    "proc fexpr {desc reexpr imexpr} {  \n"
    "   set reex [concat expr $reexpr]\n"
    "   set imex [concat expr $imexpr]\n"
    "   set np [fget $desc -np]\n"
    "   set ni [fget $desc -ni]\n"
    "   if {$ni > 1} {set np [expr $np*$ni]}\n"
    "   for {set i 1} {$i <= $np} {incr i} {\n"
    "      set c [findex $desc $i]\n"
    "      set re [lindex $c 0]\n"
    "      set im [lindex $c 1]\n"
    "      set kre [eval $reex]\n"
    "      set kim [eval $imex]\n"
    "      fsetindex $desc $i $kre $kim\n"
    "   }\n"
    "}\n"
    "\n"
    ;
/* EOF */
/* This file has been generated from the following Tcl source file(s):
 *    main.tcl
 * on Mon Nov 23 15:44:59 CET 2009 by zdenek
 */

char main_tcl[] = 
    "\n"
    "if [catch {\n"
    "  uplevel #0 {\n"
    "\n"
    "    proc savestate {} {\n"
    "      uplevel #0 {\n"
    "      if [info exists clusterstate] {unset clusterstate}\n"
    "        set clusterstate {}\n"
    "        lappend clusterstate \"global spinsys par cluster\"\n"
    "        if [info exists omitprocs(pulseq)] {unset omitprocs(pulseq)}\n"
    "        if [info exists omitprocs(main)] {unset omitprocs(main)}\n"
    "        foreach name [info vars] {\n"
    "          if [info exists omitvars($name)] continue\n"
    "          if [array exists $name] {\n"
    "             lappend clusterstate  [list array set $name \\\n"
    "               [array get $name]]\n"
    "          } else {\n"
    "             if [string compare $name clusterstate] {\n"
    "               lappend clusterstate  [list set $name [set $name]]\n"
    "             }\n"
    "          }\n"
    "        }\n"
    "        foreach name [info procs] {\n"
    "          if [info exists omitprocs($name)] continue\n"
    "          lappend clusterstate  [list proc $name \\\n"
    "            [info args $name] [info body $name]]\n"
    "        }\n"
    "        return [join $clusterstate \\n]\n"
    "      }\n"
    "    }\n"
    "\n"
    "    proc markvars {} {\n"
    "      uplevel #0 {\n"
    "        set omitvars(omitprocs) 1\n"
    "        set omitvars(omitvars) 1\n"
    "        foreach name [info vars] {\n"
    "           set omitvars($name) 1\n"
    "        }\n"
    "      }\n"
    "    }\n"
    "\n"
    "    proc markprocs {} {\n"
    "      uplevel #0 {\n"
    "        set omitprocs(markstate) 1\n"
    "        set omitprocs(savestate) 1\n"
    "        foreach name [info procs] {\n"
    "           set omitprocs($name) 1\n"
    "        }\n"
    "      }\n"
    "    }\n"
    "\n"
    "\n"
    "    if [info exists env(SIMPSON_LIB)] {\n"
    "      set path $env(SIMPSON_LIB)\n"
    "    } else {\n"
    "      set path .\n"
    "    }\n"
    "    set stop 0\n"
    "    proc evalcode {path {varname {}}} {\n"
    "       if ![string compare $varname {}] {\n"
    "         source $path\n"
    "       } else {\n"
    "         evalinternalcode $varname\n"
    "       }\n"
    "    }\n"
    "    markvars\n"
    "    evalcode $path/simpson.tcl simpson\n"
    "    evalcode $path/csafit.tcl csafit\n"
    "    evalcode $path/ftools.tcl ftools\n"
    "    evalcode $path/misc.tcl misc\n"
    "    evalcode $path/rfshapes.tcl rfshapes\n"
    "    evalcode $path/relax.tcl relax\n"
    "    markprocs\n"
    "\n"
    "    if [expr $mainargc > 1] {\n"
    "       incr argc\n"
    "       set argv [concat $argv0 $argv]  \n"
    "    }\n"
    "   if {$argc < 1} {\n"
    "      set prog [string totitle [file rootname [file tail $argv0]]]\n"
    "      puts \"$prog version $simpson_version, Copyright (C)\";\n"
    "      puts \"1999-2000 Mads Bak and Jimmy T. Rasmussen\"\n"
    "      puts \"2001 Mads Bak and Thomas Vosegaard\"\n"
    "      puts \"2002-2007 Thomas Vosegaard\"\n"
    "      puts \"2008-2009 Zdenek Tosner, Thomas Vosegaard, and Niels Chr. Nielsen\"\n"
    "      puts \"2010-2011 Zdenek Tosner, Rasmus Andersen, Niels Chr. Nielsen, and Thomas Vosegaard\\n\"\n"
    "      puts \"$prog comes with ABSOLUTELY NO WARRANTY, for details\";\n"
    "      puts \"read the COPYING file included in this distribution\"\n"
    "      puts \"This is free software, and you are welcome to redistribute\"\n"
    "      puts \"it under certain conditions according to the GNU General Public License\"\n"
    "      puts \"\\nPlease specify an inputfile, optionally with other arguments\"\n"
    "      exit\n"
    "   }\n"
    "   if ![string compare [lindex $argv 1] \"-server\"] {\n"
    "     serversimpson\n"
    "   } elseif {[lindex $argv 1] == \"-\"} {\n"
    "     set par(name) stdin\n"
    "     while {1} {\n"
    "       gets stdin d\n"
    "       if {$d == \"*\"} {break}\n"
    "       lappend data $d\n"
    "     }\n"
    "     set data [join $data \\n]\n"
    "     eval $data\n"
    "     main\n"
    "   } else {\n"
    "     regsub {(.*)\\.in} [lindex $argv 0] {\\1} par(name)\n"
    "     if [file exists $par(name).in] {\n"
    "        evalcode $par(name).in\n"
    "        main\n"
    "        internalfinalize\n"
    "     } elseif [file exists $par(name)] {\n"
    "       evalcode $par(name)\n"
    "     } else {\n"
    "       puts stderr \"error: unable to open input file '$par(name).in'\"     \n"
    "       exit\n"
    "     }\n"
    "   }\n"
    "  }\n"
    "} result] {\n"
    "  puts stderr  \"$result\"\n"
    "}\n"
    "#exit\n"
    ;
/* EOF */
/* This file has been generated from the following Tcl source file(s):
 *    misc.tcl
 * on Mon Nov 23 15:44:59 CET 2009 by zdenek
 */

char misc_tcl[] = 
    "\n"
    "\n"
    "proc csapar {s1 s2 s3} {\n"
    "  set iso [expr ($s1+$s2+$s3)/3.0]\n"
    "\n"
    "  set v [list [expr abs($s1-$iso)] [expr abs($s2-$iso)] [expr abs($s3-$iso)]]\n"
    "  set a [list $s1 $s2 $s3]\n"
    "    \n"
    "  if [expr [lindex $v 0] > [lindex $v 1] ] {\n"
    "    set v [list [lindex $v 1] [lindex $v 0] [lindex $v 2]]\n"
    "    set a [list [lindex $a 1] [lindex $a 0] [lindex $a 2]]\n"
    "  }\n"
    "\n"
    "  if [expr [lindex $v 1] > [lindex $v 2] ] {\n"
    "    set v [list [lindex $v 0] [lindex $v 2] [lindex $v 1]]\n"
    "    set a [list [lindex $a 0] [lindex $a 2] [lindex $a 1]]\n"
    "  }\n"
    "  if [expr [lindex $v 0] > [lindex $v 1] ] {\n"
    "    set v [list [lindex $v 1] [lindex $v 0] [lindex $v 2]]\n"
    "    set a [list [lindex $a 1] [lindex $a 0] [lindex $a 2]]\n"
    "  }\n"
    "\n"
    "  if [expr [lindex $v 1] > [lindex $v 2] ] {\n"
    "    set v [list [lindex $v 0] [lindex $v 2] [lindex $v 1]]\n"
    "    set a [list [lindex $a 0] [lindex $a 2] [lindex $a 1]]\n"
    "  }\n"
    "  set z [lindex $a 2]\n"
    "  set y [lindex $a 0]\n"
    "  set x [lindex $a 1]\n"
    "  \n"
    "  set aniso [expr $z-$iso ]\n"
    "  set eta [expr double($y-$x)/$aniso ];\n"
    "  return [list $iso $aniso $eta]\n"
    "}\n"
    "\n"
    "proc csaprinc {iso aniso eta} {\n"
    "  set zz [expr $aniso + $iso]\n"
    "  set xx [expr $iso-$aniso*(1.0+$eta)/2.0]\n"
    "  set yy [expr $xx + $eta*$aniso]\n"
    "  return [list $xx $yy $zz]\n"
    "}\n"
    "\n"
    "\n"
    "proc putmatrix {m {fm \"%9.3g\"}} {\n"
    "   foreach i $m {\n"
    "     foreach j $i {\n"
    "        if {[llength $j] == 2} {\n"
    "          puts -nonewline [format \"($fm,$fm) \" [lindex $j 0] [lindex $j 1]]\n"
    "        } else {\n"
    "          puts -nonewline [format $fm $j]\n"
    "        }\n"
    "     }\n"
    "     puts \"\"\n"
    "   }\n"
    "}\n"
    "\n"
    "\n"
    "\n"
    "proc contourplot {file xlabel ylabel} {\n"
    "  set f [open $file.gnu w]\n"
    "  puts $f \"\n"
    "  set param \n"
    "  set view 0,0,1\n"
    "  set cntrparam bspline\n"
    "  set cntrparam levels 10\n"
    "  set nosurface\n"
    "  set xlabel '$xlabel'\n"
    "  set ylabel '$ylabel'\n"
    "  set contour\n"
    "  set term post\n"
    "  set output '$file.ps'\n"
    "  splot '$file' w l\n"
    "  \"\n"
    "  close $f\n"
    "  exec gnuplot $file.gnu\n"
    "  puts \"Generated: $file.ps\"\n"
    "}\n"
    "\n"
    "proc 2dplot {file xlabel ylabel {title {}}} {\n"
    "\n"
    "  set f [open $file.gnu w]\n"
    "  puts $f \"\n"
    "  set term post\n"
    "  set param\n"
    "  set view 75,20,1\n"
    "  set contour\n"
    "  set title  '$title'\n"
    "  set xlabel '$xlabel'\n"
    "  set ylabel '$ylabel'\n"
    "  set output '${file}.ps'\n"
    "  plot '$file' w l\n"
    "  \"\n"
    "  close $f\n"
    "  exec gnuplot $file.gnu\n"
    "  puts \"Generated: ${file}.ps\"\n"
    "}\n"
    "\n"
    "\n"
    "proc 3dplot {file xlabel ylabel {zrange {}}} {\n"
    "\n"
    "  set zrng {}\n"
    "  if {[llength $zrange] == 2} {\n"
    "     set zrng \"set zrange \\[[join $zrange :]\\]\"\n"
    "  }\n"
    "  set f [open $file.gnu w]\n"
    "  puts $f \"\n"
    "  set term post\n"
    "  set param\n"
    "  $zrng\n"
    "  set view 75,20,1\n"
    "  set contour\n"
    "  set xlabel '$xlabel'\n"
    "  set ylabel '$ylabel'\n"
    "  set output '${file}-3d.ps'\n"
    "  splot '$file' w l\n"
    "  \"\n"
    "  close $f\n"
    "  exec gnuplot $file.gnu\n"
    "  puts \"Generated: ${file}-3d.ps\"\n"
    "}\n"
    ;
/* EOF */
/* This file has been generated from the following Tcl source file(s):
 *    simpson.tcl
 * on Mon Nov 23 15:44:59 CET 2009 by zdenek
 */

char simpson_tcl[] = 
    "\n"
    "\n"
    "\n"
    "proc signalhandler {code message} {\n"
    "  global stop sigwascalled par\n"
    "\n"
    "  if [info exists sigwascalled] {\n"
    "     puts stderr \"Program is aborted.\"\n"
    "     exit\n"
    "  }\n"
    "  set stop 1\n"
    "  puts stderr \"Received '$message', setting flag to terminate.\"\n"
    "  puts stderr \"Repeat action to abort program immediately.\"\n"
    "  set sigwascalled 1\n"
    "}\n"
    "\n"
    "proc nop args {}\n"
    "\n"
    "\n"
    "proc setvar {varname data {overwrite 0}} {\n"
    "  global $varname\n"
    "  set var $varname\n"
    "\n"
    "  set data [split $data \"\\n\"]\n"
    "\n"
    "  foreach lst $data {\n"
    "    if [string match #* [string trimleft $lst]] continue\n"
    "    set nam [lindex $lst 0]\n"
    "    if ![string length $nam] continue\n"
    "    if !$overwrite {\n"
    "      if [info exists ${var}($nam)] {\n"
    "        puts stderr \"error: '$nam' already exists in array ${var}\"\n"
    "        exit\n"
    "      }\n"
    "    }\n"
    "    set ${var}($nam) [lrange $lst 1 9999]\n"
    "  }\n"
    "}\n"
    "\n"
    "\n"
    "setvar ssnam {\n"
    "  shift N iso aniso eta alpha beta gamma\n"
    "  jcoupling N N iso aniso eta alpha beta gamma\n"
    "  quadrupole N order aniso eta alpha beta gamma\n"
    "  dipole N N aniso alpha beta gamma\n"
    "  mixing_quad_shift N\n"
    "  mixing_quad_dipole N N\n"
    "}\n"
    "\n"
    "\n"
    "proc ssSubstExpr {ex resfreq} {\n"
    "  global ssval par\n"
    "\n"
    "  if [regexp {^[0-9.Ee+-]+$} $ex] {\n"
    "    return $ex\n"
    "  }\n"
    "  set origex $ex\n"
    "  if [regsub {([0-9.Ee+-]+)p} $ex \"(\\\\1*($resfreq))\" dummy] {\n"
    "     if {$resfreq == 0} {\n"
    "        puts stderr \"error in expression '$origex'. Can only use ppm to hz convertion for chemical shift.\"\n"
    "        exit\n"
    "     }\n"
    "     if ![info exists par(proton_frequency)] {\n"
    "        puts stderr \"error in expression '$origex'. 'proton_frequency' must be set when converting ppm to Hz values.\"\n"
    "        exit\n"
    "     }\n"
    "     set freq [expr abs(($par(proton_frequency)/1.0e6)*($resfreq/1.0e6))]\n"
    "     if ![regsub {([0-9.Ee+-]+)p} $ex \"(\\\\1*($freq))\" ex] {\n"
    "        puts stderr \"error: illegal value of 'proton_frequency' = $par(proton_frequency) \"\n"
    "        exit\n"
    "     }\n"
    "  }\n"
    "  set i 0\n"
    "  while {[regsub -all {([a-z]+(_[0-9]+)+_[a-z]+)} $ex {$ssval(\\1)} ex] != 0} {\n"
    "    set ex [subst $ex]\n"
    "    if {[incr i] > 100} {\n"
    "     puts stderr \"error: substitution over 100 times af the expression '$origex'\"\n"
    "     puts stderr \"       have you made any circular references ?\"\n"
    "     exit\n"
    "    }\n"
    "  }    \n"
    "  if [catch {set ex [expr $ex]} res] {\n"
    "    puts stderr \"error: $res\"\n"
    "    exit  \n"
    "  }\n"
    "  return $ex\n"
    "}\n"
    "\n"
    "\n"
    "proc ssSetValues {} {\n"
    "  global spinsys ssval ssnam\n"
    "\n"
    "  foreach iact [array names spinsys] {\n"
    "    set val $spinsys($iact)\n"
    "    if {[string compare $iact \"nuclei\"] == 0} {\n"
    "      set ssval(nuclei) $val\n"
    "      continue\n"
    "    }\n"
    "    if {[string compare $iact \"channels\"] == 0} {\n"
    "      set ssval(channels) $val\n"
    "      continue\n"
    "    }\n"
    "    regsub {[X]+$} $iact {} iact\n"
    "\n"
    "    if ![info exists ssnam($iact)] {\n"
    "      puts stderr \"error: in spinsys section at '$iact', correct syntax is:\\n  spinsys {\"\n"
    "      foreach i [array names ssnam] {\n"
    "        puts stderr \"    $i $ssnam($i)\"\n"
    "      }\n"
    "      puts stderr \"  }\"\n"
    "      exit\n"
    "    }\n"
    "    set nam $ssnam($iact)\n"
    "\n"
    "    if {[llength $val] != [llength $nam]} {\n"
    "       puts stderr \"error: in spinsys: input list    '$iact $val'\"\n"
    "       puts stderr \"       does not match definition '$iact $nam'\"\n"
    "       exit\n"
    "    }\n"
    "    set nuc \"\"\n"
    "    set k 1\n"
    "    foreach j $nam {\n"
    "      if {[string compare $j \"N\"] == 0} {\n"
    "        set nuc \"${nuc}_[lindex $val [expr $k - 1]]\"\n"
    "      } else {\n"
    "        set ssval($iact${nuc}_$j) [lindex $val [expr $k - 1]]\n"
    "      }\n"
    "      incr k\n"
    "    }\n"
    "  }\n"
    "}\n"
    "\n"
    "\n"
    "proc ssSetSpinsys {} {\n"
    "  global spinsys spinsysres ssval ssnam\n"
    "\n"
    "  foreach iact [array names spinsys] {\n"
    "    set orignam $iact\n"
    "    set val $spinsys($orignam)\n"
    "\n"
    "    if {[string compare $iact \"nuclei\"] == 0} {\n"
    "      set spinsysres(nuclei) $ssval(nuclei)\n"
    "      continue\n"
    "    }\n"
    "    if {[string compare $iact \"channels\"] == 0} {\n"
    "      set spinsysres(channels) $ssval(channels)\n"
    "      continue\n"
    "    }\n"
    "    regsub {[X]+$} $iact {} iact\n"
    "    set nam $ssnam($iact)\n"
    "    if {[llength $val] != [llength $nam]} {\n"
    "       puts stderr \"error: input list '$val' for interaction '$iact' doesn't match definition '$nam'\"\n"
    "       exit\n"
    "    }\n"
    "    set lst {}\n"
    "    set nuc \"\"\n"
    "    set k 1\n"
    "    foreach j $nam {\n"
    "      set ival [lindex $val [expr $k - 1]]\n"
    "      if {[string compare $j \"N\"] == 0} {\n"
    "        set nuc \"${nuc}_$ival\"\n"
    "        lappend lst $ival\n"
    "      } else {\n"
    "        lappend lst $ssval($iact${nuc}_$j)\n"
    "      }\n"
    "      incr k\n"
    "    }\n"
    "    set spinsysres($orignam) $lst\n"
    "  }\n"
    "}\n"
    "\n"
    "\n"
    "proc modify {{fitval {}}} {\n"
    "  global ssval\n"
    "\n"
    "  foreach i $fitval {\n"
    "    set nam [lindex $i 0]\n"
    "    set val [lindex $i 1]\n"
    "    if ![info exists ssval($nam)] {\n"
    "      puts stderr \"error: variable '$nam' does not correspond to any variable in section 'spinsys'\"\n"
    "      exit\n"
    "    }\n"
    "    modify_parameter $nam $val\n"
    "  }\n"
    "  modify_update\n"
    "}\n"
    "\n"
    "\n"
    "\n"
    "proc spinsys_resolve { { fitval {} } } {\n"
    "  global spinsys ssval spinsysres par\n"
    "\n"
    "  ssSetValues\n"
    "  foreach i $fitval {\n"
    "    set nam [lindex $i 0]\n"
    "    set val [lindex $i 1]\n"
    "    if ![info exists ssval($nam)] {\n"
    "      puts stderr \"error: variable '$nam' does not correspond to any variable in section 'spinsys'\"\n"
    "      exit\n"
    "    }\n"
    "    set ssval($nam) $val      \n"
    "  }\n"
    "\n"
    "  ssSetSpinsys  \n"
    "  foreach i [array names spinsysres] {  \n"
    "    if ![string compare $i nuclei] {\n"
    "      set k 1\n"
    "      foreach j $spinsysres($i) {\n"
    "        set nuc($k) $j\n"
    "        incr k\n"
    "      }\n"
    "      continue\n"
    "    }\n"
    "    if ![string compare $i channels] {\n"
    "      continue\n"
    "    }\n"
    "    set lst {}\n"
    "    set resfreq 0\n"
    "    if ![string first shift $i ] {\n"
    "       set resfreq [resfreq $nuc([lindex $spinsysres($i) 0]) 1e6]\n"
    "    }\n"
    "    set k 1\n"
    "    foreach j $spinsysres($i) {\n"
    "      if {$k == 2 || $k == 3} {\n"
    "        lappend lst [ssSubstExpr $j $resfreq]\n"
    "      } else {\n"
    "        lappend lst [ssSubstExpr $j 0]\n"
    "      }\n"
    "      incr k\n"
    "    }\n"
    "    set spinsysres($i) $lst\n"
    "  }\n"
    "}\n"
    "\n"
    "proc spinsys { data } {\n"
    "  global spinsys\n"
    "\n"
    "  set okpar { channels nuclei dipole quadrupole shift jcoupling mixing_quad_shift mixing_quad_dipole }\n"
    "\n"
    "  set data [split $data \"\\n\"]\n"
    "  foreach lst $data {\n"
    "    if [string match #* [string trimleft $lst]] continue\n"
    "    set nam [lindex $lst 0]\n"
    "    if ![string length $nam] continue\n"
    "\n"
    "    if {[lsearch -exact $okpar $nam] == -1} {\n"
    "      puts stderr \"error: unknown name '$nam' in spinsys section, must be one\"\n"
    "      set f [join $okpar {, }]\n"
    "      puts stderr \"       of $f\"\n"
    "      exit\n"
    "    }\n"
    "    \n"
    "    while {[info exists spinsys($nam)]} {\n"
    "      set nam \"${nam}X\"\n"
    "    }\n"
    "    set spinsys($nam) [lrange $lst 1 9999]\n"
    "  }\n"
    "}\n"
    "\n"
    "proc cluster { data } {\n"
    "  global cluster\n"
    "\n"
    "  set indx 0\n"
    "  set data [split $data \"\\n\"]\n"
    "  foreach lst $data {\n"
    "    if [string match #* [string trimleft $lst]] continue\n"
    "    if ![llength $lst] continue\n"
    "    if {[llength $lst] < 1}  {\n"
    "       puts stderr \"error: cluster element must contain a hostname: '$lst'\"\n"
    "       exit\n"
    "    }\n"
    "    incr indx\n"
    "    set cluster($indx,hostname) [lindex $lst 0]\n"
    "    if {[llength $lst] >= 2} {\n"
    "      set cluster($indx,username) [lindex $lst 1]\n"
    "    } else {\n"
    "      set cluster($indx,username) {}\n"
    "    }\n"
    "    if {[llength $lst] >= 3} {\n"
    "      set cluster($indx,passwd)  [lindex $lst 2]\n"
    "    } else {\n"
    "      set cluster($indx,passwd) {}\n"
    "    }\n"
    "\n"
    "  }\n"
    "  set cluster(size) $indx\n"
    "}\n"
    "\n"
    "\n"
    "proc cmp_length {a b} {\n"
    "  return [expr [string length $a] < [string length $b]]\n"
    "}\n"
    "\n"
    "proc par {data} {\n"
    "  global par\n"
    "\n"
    "  set okpar {\n"
    "    proton_frequency spin_rate sw sw1 np ni method rotor_angle\n"
    "    gamma_angles fixed_rep real_spec block_diag detect_operator\n"
    "    crystal_file start_operator name verbose various variable pulse_sequence\n"
    "    conjugate_fid dipole_check gamma_zero use_cluster new_cluster cluster_port\n"
    "    inner_rotor_angle outer_rotor_angle inner_spin_rate outer_spin_rate dor\n"
    "    string oc_tol_cg oc_tol_ls oc_mnbrak_step oc_max_iter oc_cutoff \n"
    "    oc_cutoff_iter oc_var_save_iter oc_var_save_proc oc_cg_min_step oc_max_brack_eval\n"
    "    oc_max_brent_eval oc_verbose\n"
    "    rfprof_file use_3_angle_set acq_adjoint\n"
    "    zprofile zvals \n"
    "    liquid relax\n"
    "  }\n"
    "\n"
    "  set allowsubst {\n"
    "    proton_frequency spin_rate sw sw1 np ni rotor_angle\n"
    "    gamma_angles fixed_rep real_spec block_diag gamma_zero\n"
    "    inner_rotor_angle outer_rotor_angle inner_spin_rate outer_spin_rate\n"
    "    variable\n"
    "    oc_tol_cg oc_tol_ls oc_mnbrak_step oc_max_iter oc_cutoff \n"
    "    oc_cutoff_iter oc_var_save_iter oc_cg_min_step oc_max_brack_eval oc_max_brent_eval\n"
    "  }\n"
    "  set data [split $data \"\\n\"]\n"
    "  foreach lst $data {\n"
    "    if [string match #* [string trimleft $lst]] continue\n"
    "    set nam [lindex $lst 0]\n"
    "    set orignam $nam\n"
    "    if ![string length $nam] continue\n"
    "    if {[lsearch -exact $okpar $nam] == -1} {\n"
    "      puts stderr \"error: unknown name '$nam' in parameter section\"\n"
    "      exit\n"
    "    }\n"
    "    if ![string compare $nam liquid] {\n"
    "      set par($nam) [lindex $lst 1]\n"
    "      if ![string compare $par(liquid) on] {\n"
    "        if { [info exist par(spin_rate)] || [info exist par(crystal_file)] || [info exist par(gamma_angles)]} {\n"
    "          puts stderr \"error: spin_rate, crystal_file and gamma_angles not allowed when 'liquid on' is to be set\"\n"
    "          exit\n"
    "        } \n"
    "        set par(spin_rate) 0\n"
    "        set par(crystal_file) alpha0beta0\n"
    "        set par(gamma_angles) 1\n"
    "      }\n"
    "    }\n"
    "    if ![string compare $nam variable] {\n"
    "      set nam [lindex $lst 1]\n"
    "      set lst [lrange $lst 1 9999]    \n"
    "    }\n"
    "    if ![string compare $nam string] {\n"
    "      set nam [lindex $lst 1]\n"
    "      if {![string length $nam]} {\n"
    "      	puts stderr \"error: incomplete definition of string variable\"\n"
    "	exit\n"
    "      }\n"
    "      set lst [join [lrange $lst 1 9999]]    \n"
    "    }\n"
    "    if [info exists par($nam)] {\n"
    "      if [info exist par(liquid)] {\n"
    "        if ![string compare $par(liquid) on] {\n"
    "          if {![string compare $nam spin_rate] || ![string compare $nam crystal_file] || ![string compare $nam gamma_angles]} {\n"
    "	    puts stderr \"error: $nam can not be used together with liquid on\"\n"
    "	    exit\n"
    "	  }\n"
    "	}\n"
    "      } else {      \n"
    "        puts stderr \"error: '$nam' already exists in array par\"\n"
    "        exit\n"
    "      }\n"
    "    }\n"
    "    set ex [lrange $lst 1 9999]\n"
    "    if {[lsearch -exact $allowsubst $orignam] != -1} {\n"
    "      set origex $ex\n"
    "      regsub -all {([A-Za-z_][A-Za-z0-9_]*\\(?)} $ex { \\1 } ex\n"
    "      regsub -all {([0-9\\.]+) ([Ee])} $ex {\\1\\2} ex\n"
    "      regsub -all {([0-9\\.]+[Ee]) ([+-][0-9\\.]+)} $ex {\\1\\2} ex\n"
    "      set ex \"$ex \"\n"
    "      foreach n [lsort -command cmp_length [array names par]] {\n"
    "        set i 0\n"
    "        if {[string first \" $n \" $ex] != -1} {        \n"
    "          if ![regsub -all \" \\($n\\) \" $ex { $par(\\1) } ex] {\n"
    "             puts stderr \"error: unable to match $n in $ex\"\n"
    "             exit\n"
    "          }\n"
    "          set ex [subst \"$ex\"]\n"
    "        }\n"
    "      }\n"
    "      if [catch {set ex [expr $ex]} res] {\n"
    "        puts stderr \"error: $res\"\n"
    "        exit  \n"
    "      }\n"
    "    }\n"
    "    set par($nam) $ex\n"
    "  }\n"
    "}\n"
    "\n"
    "proc fsimpson {{fitpar {}}} {\n"
    "  global par _fd spinsysres\n"
    "\n"
    "  if [info exists par(verbose)] {\n"
    "    if {[string index $par(verbose) 0] == 1}  {\n"
    "      puts \"Parameters\"\n"
    "      foreach k [lsort [array names par]] {\n"
    "         puts [format \"  %-20s %s\" $k $par($k)]\n"
    "      }\n"
    "    }\n"
    "  }\n"
    "  spinsys_resolve $fitpar\n"
    "  set par(tcalc) [lindex [time {uplevel #0 {set _fd [internalsimpson]}}] 0]\n"
    "  set fd $_fd\n"
    "  unset _fd\n"
    "  return $fd\n"
    "}\n"
    "\n"
    "proc main {} {\n"
    "  set simpson987123654 {}\n"
    "  global par\n"
    "\n"
    "  set f [fsimpson]\n"
    "  fsave $f $par(name).fid\n"
    "  funload $f\n"
    "}\n"
    "\n"
    "proc pulseq {} {\n"
    "   delay 9999\n"
    "}\n"
    "\n"
    "proc pulseq_parser { data } {\n"
    "   \n"
    "   set N 0\n"
    "   set Acqs {}\n"
    "   set Res {}\n"
    "   set pcode \"\"\n"
    "   set data [split $data \"\\n\"]\n"
    "   set Nlines [llength $data]\n"
    "   for {set i 0} {$i < $Nlines} {incr i} {\n"
    "      set lst [lindex $data $i]\n"
    "      if [string match #* [string trimleft $lst]] continue\n"
    "      if { [string length [string trimleft $lst]] == 0 } continue\n"
    "      if [string match acq_block* [string trimleft $lst]] {\n"
    "	 lappend Res [concat \"namespace eval PulseqNameSpace \\{\" $pcode \"\\}\"]\n"
    "	 incr N\n"
    "	 set pcode \"\" \n"
    "	 append pcode [string trimleft $lst]\n"
    "	 while { [info complete $pcode] != 1} {\n"
    "	    incr i\n"
    "	    if { $i>= $Nlines} {\n"
    "	       puts \"pulseq_parser error: can not find end of acq_block\"\n"
    "	       exit\n"
    "	    }\n"
    "	    set lst [lindex $data $i]\n"
    "	    append pcode \"\\ncheck_dwelltime \\n\" [string trimleft $lst]\n"
    "	 }\n"
    "	 set dum [split $pcode \"\\{\"]\n"
    "	 set pcode [join [linsert $dum end-1 \"namespace eval PulseqNameSpace \"] \"\\{\"]\n"
    "	 append pcode \"\\}\"\n"
    "	 if { [info complete $pcode] != 1} {\n"
    "	    puts \"pulseq_parser: Ups, I screwed it up, look: \\n $pcode \"\n"
    "	    exit\n"
    "	 }\n"
    "	 lappend Res $pcode\n"
    "	 lappend Acqs $N\n"
    "	 incr N\n"
    "	 set pcode \"\"\n"
    "      } else {\n"
    "	 append pcode \"\\n\" [string trimleft $lst]\n"
    "      }\n"
    "   }\n"
    "   if { [string length $pcode] != 0 } {\n"
    "      lappend Res [concat \"namespace eval PulseqNameSpace \\{\" $pcode \"\\}\"]\n"
    "   }\n"
    "   \n"
    "   lappend Res $Acqs\n"
    "   return $Res\n"
    "}\n"
    "\n"
    "\n"
    "\n"
    "\n"
    "\n"
    "\n"
    ;
/* EOF */
/* This file has been generated from the following Tcl source file(s):
 *    rfshapes.tcl
 * on Mon Nov 23 15:44:59 CET 2009 by zdenek
 */

char rfshapes_tcl[] = 
    "\n"
    "proc shape2fid {{shape -1} {arg1 \"\"} {arg2 \"\"}} {\n"
    "  if {$shape == -1} {\n"
    "    puts stderr \"Usage: <desc> shape2fid <shape> <name> ?<duration>? ?(-ap|-apw|-xy)?\\n\"\n"
    "    puts stderr \"where <desc>     is the SIMPSON file descriptor returned by the command.\"\n"
    "    puts stderr \"      <shape>    is the shape descriptor.\"\n"
    "    puts stderr \"      <duration> is the duration of the shape (optional). If not specified\"\n"
    "    puts stderr \"                 it defaults to the number of points in the shape.\"\n"
    "    puts stderr \"      -ap  creates the fid as amplitude/phase in the real/imaginary part.\"\n"
    "    puts stderr \"      -apw as above but with the phase wrapped to modulo 360 degrees.\"\n"
    "    puts stderr \"      -xy  creates the fid with x-y components (default).\"\n"
    "    exit\n"
    "  }\n"
    "  set type 1\n"
    "  if {$arg1 == \"-ap\" || $arg2 == \"-ap\"} {set type 2}\n"
    "  if {$arg1 == \"-apw\" || $arg2 == \"-apw\"} {set type 3}\n"
    "  set sw 1\n"
    "  if {$arg1 != \"\" && [string is double $arg1]} {\n"
    "    set sw [expr 1.0/$arg1]\n"
    "  } elseif {$arg2 != \"\" && [string is double $arg2]} {\n"
    "    set sw [expr 1.0/$arg2]\n"
    "  }\n"
    "  if { [catch {shape_len $shape} np] } {\n"
    "      puts stderr \"shape2fid error: shape does not exist\"\n"
    "      exit\n"
    "   }\n"
    "  set f [fcreate -type fid -sw $sw -np $np -ref 0]\n"
    "  set i 1\n"
    "  switch $type {\n"
    "    1 {\n"
    "      set d2r [expr 3.1415927/180]\n"
    "      foreach l [shape2list $shape] {\n"
    "        fsetindex $f $i [expr cos($d2r*[lindex $l 1])*[lindex $l 0]] \\\n"
    "                        [expr sin($d2r*[lindex $l 1])*[lindex $l 0]]\n"
    "        incr i\n"
    "      }\n"
    "    }\n"
    "    2 {\n"
    "      foreach l [shape2list $shape] {\n"
    "        fsetindex $f $i [lindex $l 0] [lindex $l 1]\n"
    "        incr i\n"
    "      }\n"
    "    }\n"
    "    3 {\n"
    "      foreach l [shape2list $shape] {\n"
    "        set ph [lindex $l 1]\n"
    "        set ph [expr fmod($ph, 360)]\n"
    "        if {$ph < 0} {set ph [expr $ph + 360]}\n"
    "        fsetindex $f $i [lindex $l 0] $ph\n"
    "        incr i\n"
    "      }\n"
    "    }\n"
    "  }\n"
    "  return $f\n"
    "}\n"
    "\n"
    "proc shape2varian {{shape -1} {name -1} {maxrf -1}} {\n"
    "  global par\n"
    "  if {$name == -1} {\n"
    "    puts stderr \"Usage: shape2varian <shape> <name> ?<maxrf>?\"\n"
    "    exit\n"
    "  }\n"
    "  if { [catch {shape_len $shape} np] } {\n"
    "      puts stderr \"shape2varian error: shape does not exist\"\n"
    "      exit 1\n"
    "   }\n"
    "  if {$maxrf == -1} {\n"
    "    set maxrf [shape_ampl $shape -max]\n"
    "  }\n"
    "  set fp [open $name w]\n"
    "  puts $fp \"# Shape generated by SIMPSON $::simpson_version\"\n"
    "  puts $fp \"# From file: $par(name)\"\n"
    "  puts $fp \"# Date: [clock format [clock seconds]]\"\n"
    "  puts $fp \"# Points in shape: $np\"\n"
    "  foreach l [shape2list $shape] {\n"
    "    set ph [lindex $l 1]\n"
    "    set ph [expr fmod($ph, 360)]\n"
    "    if {$ph < 0} {set ph [expr $ph + 360]}\n"
    "    puts $fp [format \"%10.1f %10.1f\\t 1.0\" $ph \\\n"
    "          [expr round([lindex $l 0]/double($maxrf)*1023.0)]]\n"
    "  }\n"
    "  \n"
    "}\n"
    "\n"
    "proc shape2bruker {{shape -1} {name -1} {maxrf -1}} {\n"
    "  global par\n"
    "  if {$name == -1} {\n"
    "    puts stderr \"Usage: shape2bruker <shape> <name> ?<maxrf>?\"\n"
    "    exit\n"
    "  }\n"
    "  if { [catch {shape_len $shape} np] } {\n"
    "      puts stderr \"shape2bruker error: shape does not exist\"\n"
    "      exit 1\n"
    "  }\n"
    "  if {$maxrf == -1} {\n"
    "    set maxrf [shape_ampl $shape -max]\n"
    "  }\n"
    "  \n"
    "  set fp [open $name w]\n"
    "  puts $fp \"##TITLE= Shape genereted from file: $par(name)\"\n"
    "  puts $fp \"##USAGE= Use for OC-optimized transfer/building block\"\n"
    "  puts $fp \"##JCAMP-DX= 5.00 \\$\\$ Bruker JCAMP library\"\n"
    "  puts $fp \"##DATA TYPE= Shape Data\"\n"
    "  puts $fp \"##ORIGIN= SIMPSON $::simpson_version\"\n"
    "  puts $fp \"##DATE= [clock format [clock seconds] -f \"%D\"]\"\n"
    "  puts $fp \"##TIME= [clock format [clock seconds] -f \"%T\"]\"\n"
    "  puts $fp \"##MINX= 0.000000e+00\"\n"
    "  puts $fp \"##MAXX= 1.000000e+02\"\n"
    "  puts $fp \"##MINY= 0.000000e+00\"\n"
    "  puts $fp \"##MAXY= 3.600000e+02\"\n"
    "  puts $fp \"##\\$SHAPE_EXMODE= None\"\n"
    "  puts $fp \"##\\$SHAPE_TOTROT= 0.000000e+00\"\n"
    "  puts $fp \"##\\$SHAPE_BWFAC= 0.000000e+00\"\n"
    "  puts $fp \"##\\$SHAPE_INTEGFAC= 0.000000e+00\"\n"
    "  puts $fp \"##\\$SHAPE_MODE= 1\"\n"
    "  puts $fp \"##NPOINTS= $np\"\n"
    "  puts $fp \"##XYPOINTS= (XY..XY)\"\n"
    "  foreach l [shape2list $shape] {\n"
    "    set ph [lindex $l 1]\n"
    "    set ph [expr fmod($ph, 360)]\n"
    "    if {$ph < 0} {set ph [expr $ph + 360]}\n"
    "    puts $fp [format \"%.6e, %.6e\" \\\n"
    "          [expr [lindex $l 0]/double($maxrf)*100.0] $ph]\n"
    "  }\n"
    "  puts $fp \"##END= \"\n"
    "  close $fp\n"
    "}\n"
    ;
/* EOF */
/* This file has been generated from the following Tcl source file(s):
 *    relax.tcl
 * on Mon Nov 23 15:44:59 CET 2009 by zdenek
 */

char relax_tcl[] = 
    "\n"
    "proc relax { data } {\n"
    "   global relax par\n"
    "   \n"
    "   set gm_ok { none spherical_top symmetric_top asymmetric_top }\n"
    "   set lm_ok { rigid model_free model_free_ext diffusion_on_a_cone diffusion_in_a_cone 3_sites_jump }\n"
    "   set cc_ok { shift dipole quadrupole }\n"
    "   set auto 0\n"
    "   set cross 0\n"
    "   \n"
    "   set data [split $data \"\\n\"]\n"
    "   foreach lst $data {\n"
    "     if [string match #* [string trimleft $lst]] continue\n"
    "     set nam [lindex $lst 0]\n"
    "     if ![string length $nam] continue\n"
    "\n"
    "     switch -exact $nam {\n"
    "         global_motion {\n"
    "	                set dum [lindex $lst 1]\n"
    "                        if {[lsearch -exact $gm_ok $dum]==-1} {\n"
    "			   puts stderr \"error: unknown global motion '$dum' in relax section, must be one\" \n"
    "			   set f [join $gm_ok {, }]\n"
    "			   puts stderr \"       of $f\"\n"
    "			   exit\n"
    "			}\n"
    "			if [info exists relax($nam)] {\n"
    "                          puts stderr \"error: '$nam' already exists in array relax\"\n"
    "                          exit\n"
    "                        }\n"
    "	                set relax($nam) [lrange $lst 1 9999]\n"
    "		       }\n"
    "	 shift {\n"
    "	        set dum \"$nam\\_[lindex $lst 1]\"\n"
    "		set dum2 [lindex $lst 2]\n"
    "		if {[lsearch -exact $lm_ok $dum2]==-1} {\n"
    "		   set dum1 [regsub -all {_} $dum { }]\n"
    "	           puts stderr \"error: unknown local motion '$dum2' for '$dum1' in relax section, \" \n"
    "	           puts stderr \"       must be one of [join [lrange $lm_ok 0 3] {, }],\"\n"
    "		   puts stderr \"       [join [lrange $lm_ok 4 10] {, }]\"\n"
    "		   exit\n"
    "		}\n"
    "		if [info exists relax($dum)] {\n"
    "                  puts stderr \"error: '$dum' already exists in array relax\"\n"
    "                  exit\n"
    "                }\n"
    "		set relax($dum) [lrange $lst 2 9999]\n"
    "		incr auto\n"
    "	       }\n"
    "	 dipole {\n"
    "	         set dum \"$nam\\_[lindex $lst 1]_[lindex $lst 2]\"\n"
    "		 set dum2 [lindex $lst 3]\n"
    "		 if {[lsearch -exact $lm_ok $dum2]==-1} {\n"
    "		    set dum1 [regsub -all {_} $dum { }]\n"
    "	            puts stderr \"error: unknown local motion '$dum2' for '$dum1' in relax section, \" \n"
    "		    puts stderr \"       must be one of [join [lrange $lm_ok 0 3] {, }],\"\n"
    "		    puts stderr \"       [join [lrange $lm_ok 4 10] {, }]\"\n"
    "		    exit\n"
    "		 }\n"
    "		 if [info exists relax($dum)] {\n"
    "                    puts stderr \"error: '$dum' already exists in array relax\"\n"
    "                    exit\n"
    "                 }\n"
    "		 set relax($dum) [lrange $lst 3 9999]\n"
    "		 incr auto\n"
    "	        }\n"
    "         quadrupole {\n"
    "	             set dum \"$nam\\_[lindex $lst 1]\"\n"
    "		     set dum2 [lindex $lst 2]\n"
    "		     if {[lsearch -exact $lm_ok $dum2]==-1} {\n"
    "		        set dum1 [regsub -all {_} $dum { }]\n"
    "	                puts stderr \"error: unknown local motion '$dum2' for '$dum1' in relax section, \" \n"
    "	                puts stderr \"       must be one of [join [lrange $lm_ok 0 3] {, }],\"\n"
    "		        puts stderr \"       [join [lrange $lm_ok 4 10] {, }]\"\n"
    "		        exit\n"
    "		     }\n"
    "		     if [info exists relax($dum)] {\n"
    "                       puts stderr \"error: '$dum' already exists in array relax\"\n"
    "                       exit\n"
    "                     }\n"
    "		     set relax($dum) [lrange $lst 2 9999]\n"
    "		     incr auto\n"
    "	            }\n"
    "         random_field {\n"
    "	               set dum \"$nam\\_[lindex $lst 1]\"\n"
    "		       if [info exists relax($dum)] {\n"
    "                          puts stderr \"error: '$dum' already exists in array relax\"\n"
    "                          exit\n"
    "                       }\n"
    "		       set relax($dum) [lrange $lst 2 9999]\n"
    "		       incr auto\n"
    "		      }\n"
    "         cross_correlation {\n"
    "                            puts stderr \"error: cross correlation not implemented yet!!!\"\n"
    "			    exit\n"
    "	                    if [info exists relax($nam)] {\n"
    "                               puts stderr \"error: '$nam' already exists in array relax\"\n"
    "                               exit\n"
    "                            }\n"
    "	                    set relax($nam) [lrange $lst 1 9999]\n"
    "			    incr cross\n"
    "			   }\n"
    "         default {\n"
    "	          puts stderr \"error: unknown name '$nam' in relax section, must be one\"\n"
    "		  puts \"       of global_motion, shift, dipole, quadrupole, random_field,\"\n"
    "		  puts \"       cross_correlation\"\n"
    "		  exit\n"
    "		 }\n"
    "     \n"
    "     }\n"
    "   }\n"
    "   \n"
    "   if {[lsearch -exact [array names relax] global_motion] == -1} {\n"
    "     set relax(global_motion) none\n"
    "   }\n"
    "   set relax(auto)  $auto\n"
    "   set relax(cross) $cross\n"
    "\n"
    "}\n"
    ;
/* EOF */
TCLCODE tclcode_pointers[] = {

{"csafit", csafit_tcl},
{"ftools", ftools_tcl},
{"main", main_tcl},
{"misc", misc_tcl},
{"simpson", simpson_tcl},
{"rfshapes", rfshapes_tcl},
{"relax", relax_tcl},
{"", (char*)0}
};
